<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GreedyCopingStrategySelector.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">com.serenityai.utils</a> &gt; <span class="el_source">GreedyCopingStrategySelector.kt</span></div><h1>GreedyCopingStrategySelector.kt</h1><pre class="source lang-java linenums">package com.serenityai.utils

import com.serenityai.ui.screens.CopingExercise

/**
 * Greedy Algorithm for Selecting Emotional Coping Strategies
 * 
 * Strategy: Selects coping exercises with the best effectiveness-to-effort ratio
 * that fit within user's available time and energy constraints.
 * 
 * Time Complexity: O(n log n) - dominated by sorting
 * Space Complexity: O(n) - for storing scored exercises
 */
<span class="nc" id="L14">data class UserConstraints(</span>
<span class="nc" id="L15">    val availableTimeMinutes: Int,</span>
<span class="nc" id="L16">    val currentEnergyLevel: Int, // 1-10 scale</span>
<span class="nc" id="L17">    val currentMood: String,</span>
<span class="nc" id="L18">    val stressLevel: Int // 1-10 scale</span>
)

<span class="nc" id="L21">data class ScoredExercise(</span>
<span class="nc" id="L22">    val exercise: CopingExercise,</span>
<span class="nc" id="L23">    val score: Double,</span>
<span class="nc" id="L24">    val effectivenessRatio: Double,</span>
<span class="nc" id="L25">    val effortScore: Double,</span>
<span class="nc" id="L26">    val timeCost: Int,</span>
<span class="nc" id="L27">    val matchQuality: Double</span>
)

<span class="nc" id="L30">class GreedyCopingStrategySelector {</span>
    
    /**
     * Greedy Selection Algorithm:
     * 1. Calculate score for each exercise (effectiveness/effort ratio)
     * 2. Sort by score (descending) - greedy choice
     * 3. Select exercises until time/energy budget exhausted
     * 4. Return optimal set of strategies
     */
    fun selectOptimalStrategies(
        availableExercises: List&lt;CopingExercise&gt;,
        constraints: UserConstraints
    ): List&lt;CopingExercise&gt; {
<span class="nc bnc" id="L43" title="All 2 branches missed.">        if (availableExercises.isEmpty()) return emptyList()</span>
        
        // Step 1: Score all exercises using greedy criteria
<span class="nc" id="L46">        val scoredExercises = availableExercises.map { exercise -&gt;</span>
<span class="nc" id="L47">            calculateGreedyScore(exercise, constraints)</span>
        }
        
        // Step 2: Sort by score (descending) - Greedy choice: always pick best available
<span class="nc" id="L51">        val sortedExercises = scoredExercises.sortedByDescending { it.score }</span>
        
        // Step 3: Greedy selection - select exercises until budget exhausted
<span class="nc" id="L54">        val selectedExercises = mutableListOf&lt;CopingExercise&gt;()</span>
<span class="nc" id="L55">        var remainingTime = constraints.availableTimeMinutes</span>
<span class="nc" id="L56">        var remainingEnergy = constraints.currentEnergyLevel</span>
        
<span class="nc bnc" id="L58" title="All 2 branches missed.">        for (scoredExercise in sortedExercises) {</span>
<span class="nc" id="L59">            val timeCost = scoredExercise.timeCost</span>
<span class="nc" id="L60">            val energyCost = calculateEnergyCost(scoredExercise.exercise.difficulty)</span>
            
            // Check if exercise fits within constraints (greedy feasibility check)
<span class="nc bnc" id="L63" title="All 4 branches missed.">            if (timeCost &lt;= remainingTime &amp;&amp; energyCost &lt;= remainingEnergy) {</span>
<span class="nc" id="L64">                selectedExercises.add(scoredExercise.exercise)</span>
<span class="nc" id="L65">                remainingTime -= timeCost</span>
<span class="nc" id="L66">                remainingEnergy -= energyCost</span>
                
                // Stop if we've exhausted resources
<span class="nc bnc" id="L69" title="All 4 branches missed.">                if (remainingTime &lt;= 0 || remainingEnergy &lt;= 0) {</span>
<span class="nc" id="L70">                    break</span>
                }
            }
        }
        
<span class="nc" id="L75">        return selectedExercises</span>
    }
    
    /**
     * Calculate greedy score: effectiveness / effort ratio
     * Higher score = better choice (greedy heuristic)
     */
    private fun calculateGreedyScore(
        exercise: CopingExercise,
        constraints: UserConstraints
    ): ScoredExercise {
<span class="nc" id="L86">        val effectiveness = exercise.effectiveness.toDouble()</span>
<span class="nc" id="L87">        val effort = calculateEffort(exercise)</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        val effectivenessRatio = if (effort &gt; 0) effectiveness / effort else effectiveness</span>
        
        // Match quality: how well exercise matches current mood
<span class="nc" id="L91">        val matchQuality = calculateMatchQuality(exercise, constraints)</span>
        
        // Time cost
<span class="nc" id="L94">        val timeCost = parseDurationToMinutes(exercise.duration)</span>
        
        // Greedy score formula: maximize benefit while minimizing cost
        // Score = (Effectiveness * MatchQuality) / (Effort * TimeCost)
<span class="nc" id="L98">        val score = (effectiveness * matchQuality) / (effort * timeCost.coerceAtLeast(1))</span>
        
<span class="nc" id="L100">        return ScoredExercise(</span>
<span class="nc" id="L101">            exercise = exercise,</span>
<span class="nc" id="L102">            score = score,</span>
<span class="nc" id="L103">            effectivenessRatio = effectivenessRatio,</span>
<span class="nc" id="L104">            effortScore = effort,</span>
<span class="nc" id="L105">            timeCost = timeCost,</span>
<span class="nc" id="L106">            matchQuality = matchQuality</span>
        )
    }
    
    /**
     * Calculate effort score based on difficulty
     * Lower effort = higher score (easier to do)
     */
    private fun calculateEffort(exercise: CopingExercise): Double {
<span class="nc bnc" id="L115" title="All 10 branches missed.">        return when (exercise.difficulty.lowercase()) {</span>
<span class="nc" id="L116">            &quot;easy&quot; -&gt; 1.0</span>
<span class="nc" id="L117">            &quot;medium&quot; -&gt; 2.0</span>
<span class="nc" id="L118">            &quot;hard&quot; -&gt; 3.0</span>
<span class="nc" id="L119">            else -&gt; 2.0</span>
        }
    }
    
    /**
     * Calculate energy cost based on difficulty
     */
    private fun calculateEnergyCost(difficulty: String): Int {
<span class="nc bnc" id="L127" title="All 10 branches missed.">        return when (difficulty.lowercase()) {</span>
<span class="nc" id="L128">            &quot;easy&quot; -&gt; 1</span>
<span class="nc" id="L129">            &quot;medium&quot; -&gt; 2</span>
<span class="nc" id="L130">            &quot;hard&quot; -&gt; 3</span>
<span class="nc" id="L131">            else -&gt; 2</span>
        }
    }
    
    /**
     * Calculate how well exercise matches user's current mood
     * Higher match = better fit for current emotional state
     */
    private fun calculateMatchQuality(
        exercise: CopingExercise,
        constraints: UserConstraints
    ): Double {
<span class="nc" id="L143">        var quality = 1.0</span>
        
        // Boost if exercise matches current mood
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (exercise.moodTags.contains(constraints.currentMood)) {</span>
<span class="nc" id="L147">            quality += 0.5</span>
        }
        
        // Boost if exercise is effective for high stress
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (constraints.stressLevel &gt;= 7 &amp;&amp; exercise.moodTags.contains(&quot;Stressed&quot;)) {</span>
<span class="nc" id="L152">            quality += 0.3</span>
        }
        
        // Boost based on past success (times completed)
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (exercise.timesCompleted &gt; 0) {</span>
<span class="nc" id="L157">            quality += (exercise.timesCompleted * 0.1).coerceAtMost(0.5)</span>
        }
        
        // Slight boost for completed exercises (user familiarity)
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (exercise.isCompleted) {</span>
<span class="nc" id="L162">            quality += 0.2</span>
        }
        
<span class="nc" id="L165">        return quality</span>
    }
    
    /**
     * Parse duration string to minutes
     */
    private fun parseDurationToMinutes(duration: String): Int {
<span class="nc" id="L172">        return try {</span>
<span class="nc" id="L173">            val parts = duration.split(&quot; &quot;)</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            val number = parts[0].toIntOrNull() ?: 5</span>
<span class="nc" id="L175">            number</span>
<span class="nc" id="L176">        } catch (e: Exception) {</span>
<span class="nc" id="L177">            5 // Default to 5 minutes</span>
        }
    }
    
    /**
     * Get top N highest-scoring exercises (quick greedy recommendation)
     */
<span class="nc" id="L184">    fun getTopRecommendations(</span>
        availableExercises: List&lt;CopingExercise&gt;,
        constraints: UserConstraints,
<span class="nc" id="L187">        topN: Int = 3</span>
    ): List&lt;CopingExercise&gt; {
<span class="nc" id="L189">        val scored = availableExercises.map { exercise -&gt;</span>
<span class="nc" id="L190">            calculateGreedyScore(exercise, constraints)</span>
<span class="nc" id="L191">        }.sortedByDescending { it.score }</span>
        
<span class="nc" id="L193">        return scored.take(topN).map { it.exercise }</span>
    }
    
    /**
     * Calculate total expected benefit from selected strategies
     */
    fun calculateTotalBenefit(selectedExercises: List&lt;CopingExercise&gt;): Double {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        return selectedExercises.sumOf { it.effectiveness.toDouble() }</span>
    }
    
    /**
     * Calculate total time investment
     */
    fun calculateTotalTime(selectedExercises: List&lt;CopingExercise&gt;): Int {
<span class="nc bnc" id="L207" title="All 2 branches missed.">        return selectedExercises.sumOf { parseDurationToMinutes(it.duration) }</span>
    }
    
    /**
     * Get strategy selection explanation (why these were chosen)
     */
    fun explainSelection(
        selectedExercises: List&lt;CopingExercise&gt;,
        constraints: UserConstraints
    ): String {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (selectedExercises.isEmpty()) {</span>
<span class="nc" id="L218">            return &quot;No exercises selected - constraints may be too restrictive&quot;</span>
        }
        
<span class="nc" id="L221">        val totalTime = calculateTotalTime(selectedExercises)</span>
<span class="nc" id="L222">        val avgEffectiveness = selectedExercises.map { it.effectiveness }.average()</span>
        
<span class="nc" id="L224">        return buildString {</span>
<span class="nc" id="L225">            append(&quot;Selected ${selectedExercises.size} exercises based on:\n&quot;)</span>
<span class="nc" id="L226">            append(&quot;• Highest effectiveness-to-effort ratio\n&quot;)</span>
<span class="nc" id="L227">            append(&quot;• Best match for ${constraints.currentMood} mood\n&quot;)</span>
<span class="nc" id="L228">            append(&quot;• Total time: $totalTime minutes\n&quot;)</span>
<span class="nc" id="L229">            append(&quot;• Average effectiveness: ${String.format(&quot;%.1f&quot;, avgEffectiveness)}/5.0&quot;)</span>
<span class="nc" id="L230">        }</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>